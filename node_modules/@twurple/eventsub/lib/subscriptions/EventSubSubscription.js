"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubSubscription = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@twurple/common");
const crypto = require("crypto");
/**
 * A subscription to an EventSub event.
 *
 * @hideProtected
 */
let EventSubSubscription = class EventSubSubscription {
    /** @private */
    constructor(_handler, _client) {
        this._handler = _handler;
        this._client = _client;
        this._verified = false;
    }
    /**
     * Whether the subscription has been verified by Twitch.
     */
    get verified() {
        return this._verified;
    }
    get _secret() {
        return `${this.id}.${this._client._secret}`.slice(-100);
    }
    /** @private */
    get _twitchId() {
        var _a;
        return (_a = this._twitchSubscriptionData) === null || _a === void 0 ? void 0 : _a.id;
    }
    /** @private */
    _verify() {
        this._verified = true;
    }
    /** @private */
    _verifyData(messageId, timestamp, body, algoAndSignature) {
        const [algorithm, signature] = algoAndSignature.split('=', 2);
        const hash = crypto
            .createHmac(algorithm, this._secret)
            .update(messageId + timestamp + body)
            .digest('hex');
        return hash === signature;
    }
    /** @private */
    _handleData(body) {
        this._handler(this.transformData(body));
    }
    /**
     * Activates the subscription.
     *
     * You don't have to call this method manually after subscribing, as it's done automatically.
     * It's only used to reactivate a subscription after calling `.stop()`.
     *
     * @param resumeFrom The subscription data from Twitch to check whether the subscription needs to be re-added.
     */
    async start(resumeFrom) {
        if (resumeFrom) {
            if (resumeFrom.status === 'enabled') {
                this._twitchSubscriptionData = resumeFrom;
                this._client._logger.debug(`Successfully resumed subscription for event: ${this.id}`);
                return;
            }
            this._client._logger.info(`Cycling broken conflicting subscription for event: ${this.id}`);
            await this._unsubscribe();
        }
        this._twitchSubscriptionData = await this._subscribe();
        this._client._registerTwitchSubscription(this.id, this._twitchSubscriptionData);
    }
    /**
     * Suspends the subscription, not removing it from the listener.
     */
    async suspend() {
        if (!this._twitchSubscriptionData) {
            return;
        }
        await this._unsubscribe();
        this._twitchSubscriptionData = undefined;
    }
    /**
     * Deactivates the subscription and removes it from the listener.
     */
    async stop() {
        await this.suspend();
        this._client._dropSubscription(this.id);
    }
    /**
     * Outputs the base command to execute for testing the subscription using the Twitch CLI.
     *
     * Some additional parameters, like the target user, may be required.
     */
    async getCliTestCommand() {
        return `twitch event trigger ${this._cliName} -F ${await this._client._buildHookUrl(this.id)} -s ${this._secret}`;
    }
    async _getTransportOptions() {
        return {
            method: 'webhook',
            callback: await this._client._buildHookUrl(this.id),
            secret: this._secret
        };
    }
    async _unsubscribe() {
        if (this._twitchSubscriptionData) {
            await this._client._apiClient.eventSub.deleteSubscription(this._twitchSubscriptionData.id);
        }
        this._client._dropTwitchSubscription(this.id);
    }
};
EventSubSubscription = tslib_1.__decorate([
    (0, common_1.rtfm)('eventsub', 'EventSubSubscription')
], EventSubSubscription);
exports.EventSubSubscription = EventSubSubscription;
